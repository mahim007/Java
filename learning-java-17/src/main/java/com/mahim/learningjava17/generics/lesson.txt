1. m1(ArrayList<String> l) -> only String type

2. m1(ArrayList<?> l) -> call this method by passing array-list of any unknown type. but within the method we can't add anything
    to the list except null. because we don't know type exactly.
    null is allowed because it's a valid value for any type.
    this type of methods are best suitable for read only operation.

3. m1(ArrayList<? extends X> l) -> X can be either class or interface. if X is a class then we can call this method by
    passing ArrayList of either X type or it's child classes.
    if X is an interface, then we can call this method by passing ArrayList of either X type or it's implementation
    classes.
    But within the method we can't add anything to the list, except null. because we don't know the type of X exactly.
    This type of method also best suitable for read only operation.

4. m1(ArrayList<? super X> l) -> X can be either class or interface.
    if X is a class then we can call this method bypassing ArrayList of either X type or it's super classes.
    if X is an interface, then we can call this method by passing ArrayList of either X type or super class of implementation
    class of X.
    But within the method we can add X type of object and null to the list.


-- some example
ArrayList<?> l = new ArrayList<?>();
CompileTime Error: unexpected type
found: ?
required: class or interface without bound.

ArrayList<?> l = new ArrayList<? extends Number>();
CompileTime Error: unexpected type
found: ? extends Number
required: class or interface without bound.
