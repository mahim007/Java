1. m1(ArrayList<String> l) -> only String type

2. m1(ArrayList<?> l) -> call this method by passing array-list of any unknown type. but within the method we can't add anything
    to the list except null. because we don't know type exactly.
    null is allowed because it's a valid value for any type.
    this type of methods are best suitable for read only operation.

3. m1(ArrayList<? extends X> l) -> X can be either class or interface. if X is a class then we can call this method by
    passing ArrayList of either X type or it's child classes.
    if X is an interface, then we can call this method by passing ArrayList of either X type or it's implementation
    classes.
    But within the method we can't add anything to the list, except null. because we don't know the type of X exactly.
    This type of method also best suitable for read only operation.

4. m1(ArrayList<? super X> l) -> X can be either class or interface.
    if X is a class then we can call this method bypassing ArrayList of either X type or it's super classes.
    if X is an interface, then we can call this method by passing ArrayList of either X type or super class of implementation
    class of X.
    But within the method we can add X type of object and null to the list.


-- some example
ArrayList<?> l = new ArrayList<?>();
CompileTime Error: unexpected type
found: ?
required: class or interface without bound.

ArrayList<?> l = new ArrayList<? extends Number>();
CompileTime Error: unexpected type
found: ? extends Number
required: class or interface without bound.

-- we can declare type parameter either at class level or method level
-- declaring type parameter at class level
class Test<T> {
    we can use T within this class based on our requirement.
}

-- declaring type parameter at method level: we have to declare type parameter just before return type
class Test{
    public <T> void m1(){
        we can use T anywhere in this method based on our requirement.
    }
}

-- we can define bounded types even at method level also.
public <T> void m1()
public <T extends Number> void m1()
public <T extends Runnable> void m1()
public <T extends Number & Runnable> void m1()
public <T extends Comparable & Runnable> void m1()
public <T extends Number & Comparable & Runnable> void m1()
public <T extends Runnable & Number> void m1() [first we have to take class and then interface]
public <T extends Number & Thread> void m1() [we can't extend more than one class]


---- communication with non-generic code
-- if we send generic object to non-generic area, then it starts behaving like non-generic object. similarly, if we send
    non-generic object to generic area, it starts behaving like generic object. That is the location in which the object
    present. Based on that behavior will be defined.
    see GenericAreaDemo.java


-- The main purpose of generics is to provide type safety and to resolve type casting problems.
    type safety and type casting - both are applicable at compile time, hence generics concept applicable only at
    compile time but not at runtime.
    At the time of compilation as last step generics syntax will be removed. And hence for the JVM generic syntax won't
    be available.
    see Test2.java

-- Hence the following declarations are equal
    ArrayList l = new ArrayList<String>();
    ArrayList l = new ArrayList<Integer>();
    ArrayList l = new ArrayList<Double>();
    ArrayList l = new ArrayList();

-- the following declarations are equal
    ArrayList<String> l = new ArrayList<String>();
    ArrayList<String> l = new ArrayList<>();

    for this ArrayList object we can add only String type objects.

-- At compile time:
    1. Compile code normally by considering generic syntax
    2. Remove generic syntax
    3.Compile once again resultant code
    see Test3.java